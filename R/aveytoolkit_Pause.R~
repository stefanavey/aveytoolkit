#' Pause
#'
#' This function prompts for return key and waits until the return is pushed to continue execution. It is used often to view plots coded in a loop one at a time allowing the user to control when the next plot should be displayed
#'
#' @param str optional string to display. Defaults to "continue".
#' @param quiet if TRUE, no prompt is displayed. Default is FALSE
#' @return NULL is returned by invisible
#' @author Stefan Avey
#' @details The Pause function uses readline to wait until a newline character (produced by the Enter key) is given.  Instead of pressing 
#' @keywords aveytoolkit
#' @export
#' @examples
#' for(p in 1:10) {
#'   plot(-10:10, (-10:10)^p, type='b')
#'   Pause(paste0('see plot of x^',p))
#' }
Pause <- function (str="continue", quiet=FALSE) {
  if(quiet)
    prompt <- ""
  else
    prompt <- paste("Press <Enter> to ", str, "... ", sep="")
  readline(prompt=prompt)
  invisible()
}

################################################################################
## Copied from Stack Overflow
## http://stackoverflow.com/questions/5789982/reset-par-to-the-default-values-at-startup
## Simple function to reset plotting parameters for when things get wonky
resetPar <- function() {
      dev.new()
          op <- par(no.readonly = TRUE)
          dev.off()
          op
    }

################################################################################
### Combine p-values using fishers method
fishersMethod = function(x) pchisq(-2 * sum(log(x)),df=2*length(x),lower=FALSE)

################################################################################
### Average the replicates in a matrix or dataframe
### Assumes that the replicates are all next to each other
AverageReplicates <- function(eSubSet, numRep) 
  {
    avgESubSet <- data.frame(matrix(nrow=nrow(eSubSet), ncol=ncol(eSubSet)/numRep),
                             row.names=rownames(eSubSet))
    colnames(avgESubSet) <- paste(colnames(eSubSet)[seq(1,ncol(eSubSet), numRep)],
                                  "avg", sep=".")
    for(row in 1:nrow(eSubSet))
      avgESubSet[row,] <- colMeans(matrix(as.numeric(eSubSet[row,]),
                                          nrow=numRep, ncol=ncol(eSubSet)/numRep))
    return(avgESubSet)
  }


################################################################################
## sigHeatmap - Draw Activity Heatmap with stars on boxes for significant values
################################################################################
## Only rows with at least one significant column are plotted
## ARGUMENTS:
## - pvals should be a list or data frame of (FDR corrected) positive pvalues
## - pvalDisplayName is printed on the heatmap as a legend as in:
##   * [pvalDisplayName] < [cutoff].  Default is 'P-value' but might want to say
##   FDR or something else
## - cutoff is threshold for pvalue significance (default 0.05)
## - hm is a matrix or dataframe of values for drawing the heatmap
## - plotTitle is a string used for plotting the title
## - sigMethod: if both, plots both positive and negative significant changes
##   if up or down, plots only rows of hm with significant positive or negative
##   values respectively
## Any other parameters passed in will be passed to the heatmap.2 function
## RETURN VALUE: A heatmap is plotted and the significant subset of hm
## is returned
sigHeatmap <- function(hm, pvals, pvalDisplayName="P-value", cutoff=0.05,
                       sigMethod=c("both", "up", "down"), plotTitle="",
                       Rowv=T, ...)
{
  ## Do some checking for conditions we do not want
  if(any(unlist(pvals) < 0) || any(unlist(pvals) > 1))
    stop("pvals should be in interval [0, 1]")
  require(gplots) # for heatmap function
  pvals <- as.data.frame(pvals)
  sigMethod <- match.arg(sigMethod)
  subset <- rep(NA, nrow(pvals))
  switch(sigMethod,
         both =  { subset <- apply(pvals, 1, function(row) any(row < cutoff))
                   cn <- pvals[subset,] < cutoff },
         up = { for(i in 1:nrow(pvals)) {subset[i] <- any(pvals[i,] < cutoff
                                                          & hm[i,] > 0) }
                cn <- pvals[subset,] < cutoff & hm[subset,] > 0 },
         down = { for(i in 1:nrow(pvals)) {subset[i] <- any(pvals[i,] < cutoff
                                                            & hm[i,] < 0) }
                  cn <- pvals[subset,] < cutoff & hm[subset,] < 0 }
         )
## cellnote (cn) begins as true or false and is replaced by * or ""
  ## Replace T and F with "*" and "" respectively
  for(i in 1:nrow(cn)) { 
    for(j in 1:ncol(cn)) {
      if(cn[i,j]) {cn[i,j] <- "*"}
      else {cn[i,j] <- ""}
    }
  }
#  subset2 <- apply(cn, 1, function(row) any(row == "*"))
  if(Rowv) {
    hr <- hclust(as.dist(1-cor(t(hm[subset,]), method="spearman")), method="ward")
    heatmap.2(hm[subset,], cellnote=cn, Rowv=as.dendrogram(hr), ...)
  } else
    heatmap.2(hm[subset,], cellnote=cn, Rowv=Rowv, ...)  
  title(main=paste0("\n\n\n\n", plotTitle,"\n\n\n\n\n* ", pvalDisplayName, " < ", cutoff))
  return(invisible(which(subset))) # return subset
}

################################################################################
## Plot helper function for PlotPCATimeCourse
################################################################################
## Colors are assumed to have as the names attribute some part of the sampleName
## which can uniquely identify it
## Also used to plot 2 genes expression against each other over time
## alpha is transparency factor used in alpha function from scales library
## if plotType==times
## If legend.loc="none", no legend is plotted
## ctrl: <T/F> Flag for whether or not first numRep values in x and y are
## from a control measurement
PlotTimeCourse <- function(x, y, colors, groups, sampleNames, pch=19, plotTitle="", 
                           legend.loc="topleft", plotType=c("times", "points"),
                           alpha=0.15, cex.pt=1, cex.time=2, time.adj=c(-.3,-.3),
                           arrLen=.1, lwd=3, numRep=3, plotFont=NULL, ctrl=TRUE,
                           hourMarks=TRUE, legend.cex=2, ...)
{
  plot(x, y, type="n", main=plotTitle, ...)
  plotType <- match.arg(plotType)
  switch(plotType,
         times = text(x, y, labels=pch, col=colors[groups], cex=cex.pt, font=plotFont),
         points = {  require(scales)
                     if(numRep > 1) { # only if there are points not on lines
                       if(ctrl) # if first time points are control
                         cols <- c(colors[groups[1:numRep]], alpha(colors[groups[-(1:numRep)]], alpha))
                       else
                         cols <- alpha(colors[groups], alpha)
                       if(is.numeric(pch)) # probably want to plot symbols if numeric
                         points(x, y, pch=pch, col=cols, cex=cex.pt)
                       else
                         text(x, y, labels=pch, col=cols, cex=cex.pt, font=plotFont)
                     }
                   }
         )
  for(i in 1:length(colors)) { # Loop through conditions
    whichCols <- grep(names(colors)[i], sampleNames, fixed=T)
    x.avg <- rowMeans(matrix(x[whichCols], ncol=numRep, byrow=TRUE))
    y.avg <- rowMeans(matrix(y[whichCols], ncol=numRep, byrow=TRUE))
    if(length(whichCols) > numRep) { # if there is more than one time point
      if(hourMarks) {
        if(names(colors)[i] == "AlaF") # AlaF only has 7 time points so change whichVals
          whichVals <- c(4,7)
        else
          whichVals <- c(4,8)
        text(x.avg[whichVals], y.avg[whichVals], labels=c("4", "8"), col=colors[i],
             adj=time.adj, cex=cex.time, font=plotFont)
      }
      if(ctrl) { # if Control time point is included
        conSamp <- grep("Control", sampleNames)
        arrows(mean(x[conSamp]), mean(y[conSamp]), x.avg[1], y.avg[1], col=colors[i], length=arrLen,
               lwd=lwd)
      }
      for(j in 1:(length(x.avg)-1))
        arrows(x.avg[j], y.avg[j], x.avg[j+1], y.avg[j+1], col=colors[i], length=arrLen,
               lwd=lwd)
    }
    ## lines(x.avg, y.avg, col=colors[i])
  }
  legNames <- names(colors)
  funcStrains <- c("Brevig", "Cal", "NC", "Tx")
  names(funcStrains) <- c("1918", "Cal/09", "NC", "TX") # 'official names'
  legNames[match(funcStrains, names(colors), nomatch=0)] <- names(funcStrains)[match(names(colors), funcStrains, nomatch=0)]
  if(legend.loc != "none")
    legend(legend.loc, legNames, fill=colors, cex=legend.cex)
}

################################################################################
### ComputeTimeLag
################################################################################
### gp1.gene and gp2 are interpolated gene profiles for two strains
### gene is the row in gp1 and gp2 for the gene of interest
### lags is vector of time lags between strain 1 and strain 2. Must be
### symmetric about 0 and ordered in increasing order
ComputeTimelag <- function(gp1.gene, gp2, gene, lags, cor.method="pearson")
{
  n <- length(lags)
  if(is.character(gene))
    gene <- which(rownames(gp2) == gene)
  ## For each of the lags
  piT <- list()
  muT <- list()
  for(k in floor(n/2):0) { # shifting gp2 to the right wrt gp1   
    sp1.gene <- matrix(c(rep(NA, k), gp1.gene))
    sp2 <- cbind(gp2, matrix(NA, nrow=nrow(gp2), ncol=k))
    ## Took out -gene from sp2[-gene,] here in the next 2 commands
    ## Not technically correct because background distribution should be
    ## calculated without using the gene itself but should produce very similar answer
    ## since there are ~ 30K genes
    piT[[ceiling(n/2)-k]] <- array(cor(t(sp2), sp1.gene, use="pairwise.complete.obs",
                                       method=cor.method))
#    muT[[ceiling(n/2)-k]] <- sapply(piT[[ceiling(n/2)-k]], function(score)
#                                    mean(score > piT[[ceiling(n/2)-k]]))
    muT[[ceiling(n/2)-k]] <- mean(piT[[ceiling(n/2)-k]][gene] > piT[[ceiling(n/2)-k]][-gene])    
  }
  for(k in 1:floor(n/2)) { # shifting gp2 to the left wrt gp1
    sp1.gene <- matrix(c(gp1.gene, rep(NA, k)))
    sp2 <- cbind(matrix(NA, nrow=nrow(gp2), ncol=k), gp2)
    piT[[ceiling(n/2)+k]] <- array(cor(t(sp2), sp1.gene, use="pairwise.complete.obs",
                                       method=cor.method))
#    muT[[ceiling(n/2)+k]] <- sapply(piT[[ceiling(n/2)+k]], function(score)
#                                    mean(score > piT[[ceiling(n/2)+k]]))
    muT[[ceiling(n/2)+k]] <- mean(piT[[ceiling(n/2)+k]][gene] > piT[[ceiling(n/2)+k]][-gene])
  }
  ## Find the "optimal timelag" by choosing the tau for each gene that maximizes muT
  ## Negative sign ensures proper directionality.
  muT.df <- as.data.frame(muT)
  ## To make faster, only calculate for the gene of interest
  ##  phi <- apply(muT.df, 1, function(row) -lags[which.max(row)]) # optimal time lag
  phi.gene <- -lags[which.max(muT.df[gene,])]
  ##  omega <- apply(muT.df, 1, function(row) {1- max(row)}) # significance
  omega.gene <- 1 - max(muT.df[gene,])
  ##  return(list(optimalLag=phi[gene], significance=omega[gene]))
  return(list(optimalLag=phi.gene, significance=omega.gene))
}

################################################################################
### ProcessNames function takes in a character array and manipulates it to make
### nice names (e.g. for the columns of a data frame) from a description
### It returns the manipulated character array with words separated by '_'
### stringsToRm are replaced by nothing '' and rmPunct removes all punctuation
ProcessNames <- function(charArray, stringsToRm=NULL, rmPunct=TRUE, sep="_")
  {
    if(rmPunct) # remove punctuation
      charArray <- gsub("[[:punct:]]", '', charArray) 
    for (str in stringsToRm) # remove strings in stringsToRm
      charArray <- gsub(str, '', charArray)
    charArray <- gsub(' ', sep, charArray, fixed=TRUE) # change spaces to underscores
    return(charArray)
  }


################################################################################
### smartBoxPlot - this will do some smart things using the labels to generate
### box plots from a matrix of data
SmartBoxplot <- function(mat, cats, rows, cols=NA, whichCols=NA, sep='.',
                         colorby=c(1,2), ...)
  {
    require(gtools)
    ## explicitly define levels to maintain same order as in cats
    cats <- factor(cats, levels=mixedsort(unique(cats)))
    for(r in rows) {
      if(is.na(cols) && !is.na(whichCols)) {
        submat <- mat[rows,whichCols]
        ## Find the common string separated  sep in the column names
        m <- Reduce(intersect,
                    strsplit(colnames(exprFClist[[cellType]])[whichCols], sep, fixed=T))
      } else if (is.na(whichCols) && !is.na(cols)) {
        submat <- mat[rows,grep(paste0(sep, cols, sep), colnames(mat), fixed=T)]
        m <- cols
        }
      else
        stop("Must specify columns in cols or whichCols argument")
      colorCats <- as.factor(unlist(lapply(
        strsplit(levels(cats), sep, fixed=T), '[[', colorby)))
      colors <- c("yellow", "blue")[colorCats]
      x <- data.frame(vals=unlist(submat), cats=cats)
#      print(x)
      print(levels(cats))
      if(is.numeric(r))
        rowName <- rownames(mat)[r]
      else
        rowName <- r
      boxplot(vals ~ cats, data=x, ylab=rowName, main=m, col=colors,
              ...)
    }
  }



################################################################################
### ggsmartBoxPlot - this will do some smart things using the labels to generate
### box plots from a matrix of data - using ggplot2
ggSmartBoxplot <- function(x, mat,splitBy, colorBy, rows, cols=NA,
                           whichCols=NA, sep='.', fileName=NA,
                           ...)
  {
    require(gtools)
    require(ggplot2)
    if(is.character(fileName))
      pdf(fileName)
    for(r in rows) {
      if(is.na(cols) && !is.na(whichCols)) {
        submat <- mat[r,whichCols]
        ## Find the common string separated  sep in the column names
      } else if (is.na(whichCols) && !is.na(cols)) {
        submat <- mat[r,grep(paste0(sep, cols, sep), colnames(mat), fixed=T)]
        }
      else
        stop("Must specify columns in cols or whichCols argument")
      ## x2 is defined 
      x2 <- as.numeric(as.factor(x)) +
        0.25*seq(from=-1, to=1,
                 length.out=length(levels(factor(colorBy))))[as.numeric(factor(colorBy))]
      dat <- data.frame(x=factor(x), x2=x2, vals=unlist(submat), splitBy=splitBy,
                      colorBy=factor(colorBy))
#      print(dat)
      ## Assign rownames as r or the rownames at row number r
      if(is.numeric(r))
        rowName <- rownames(mat)[r]
      else
        rowName <- r
#f <- ggplot(dat, aes(x=x, y=vals)) +                                       
#        scale_x_discrete() +
#          geom_boxplot(aes(fill=colorBy), color=c("yellow", "blue"), outlier.shape=NA,
#                       position=position_dodge(1)) +
      f <- qplot(x, vals, data = dat, geom="boxplot", ylab=rowName, fill=colorBy,
                 position=position_dodge(1),
                 outlier.shape=NA,
                 ...) +
                   scale_fill_manual(name="", breaks=factor(colorBy),
                                     values=c("yellow", "blue")
                                     ) +
          geom_jitter(aes(x=x2), position=position_jitter(width=0.1)) +
            facet_grid(.~splitBy, scales="free", space="free") +                         
              theme_bw() +
                theme(plot.margin=unit(c(5, 0, 5, 10), "mm"),
                      text=element_text(size=16),
                      axis.title.x = element_text(vjust=-.75),
                      axis.title.y = element_text(vjust=0))
      plot(f)
    }
    if(is.character(fileName))
      dev.off()
  }


################################################################################
### Copied directly from stack overflow here:
### http://stackoverflow.com/questions/8047668/transparent-equivalent-of-given-color
### Just makes it quicker to add transparency to colors for plotting
makeTransparent = function(..., alpha=0.5) {
    if(alpha<0 | alpha>1) stop("alpha must be between 0 and 1")
      alpha = floor(255*alpha)
      newColor = col2rgb(col=unlist(list(...)), alpha=FALSE)
      .makeTransparent = function(col, alpha) {
            rgb(red=col[1], green=col[2], blue=col[3], alpha=alpha, maxColorValue=255)
          }
      newColor = apply(newColor, 2, .makeTransparent, alpha=alpha)
      return(newColor)
  }
################################################################################


